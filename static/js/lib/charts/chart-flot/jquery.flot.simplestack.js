// Generated by CoffeeScript 1.6.3
(function() {
  (function($) {
    var init, options;
    options = {
      series: {
        stack: null
      }
    };
    init = function(plot) {
      var baseArray, baseHash, countBases, groupInterval, offset, stackData;
      baseHash = null;
      baseArray = null;
      groupInterval = 0;
      offset = 0;
      countBases = function(data) {
        baseHash = {};
        baseArray = [];
        data.forEach(function(s) {
          if ((s.stack != null) && s.stack) {
            return s.data.forEach(function(point) {
              var x;
              x = point[0];
              if (groupInterval > 0) {
                x = Math.round((x - offset) / groupInterval) * groupInterval + offset;
              }
              if (baseHash[x]) {
                return baseHash[x].cnt++;
              } else {
                baseHash[x] = {
                  cnt: 1,
                  pos: 0,
                  neg: 0
                };
                return baseArray.push(x);
              }
            });
          }
        });
        baseArray = baseArray.sort(function(a, b) {
          return a - b;
        });
      };
      stackData = function(plot, s, datapoints) {
        var base, i, opt, points, pointsHash, ps, x, y;
        if ((s.group != null) && s.group) {
          groupInterval = s.groupInterval || 0;
          opt = s.xaxis.options;
          if (opt.mode === 'time' && opt.timezone === 'browser') {
            offset = (new Date()).getTimezoneOffset() * 60000;
          }
        }
        if (!baseHash) {
          countBases(plot.getData());
        }
        if ((s.stack == null) || s.stack === false) {
          return;
        }
        points = datapoints.points;
        pointsHash = {};
        ps = datapoints.pointsize;
        i = 0;
        while (i < points.length) {
          x = points[i];
          y = points[i + 1];
          if (y >= 0) {
            pointsHash[x] = [x, y + baseHash[x].pos, baseHash[x].pos];
            baseHash[x].pos += y;
          } else {
            pointsHash[x] = [x, y + baseHash[x].neg, baseHash[x].neg];
            baseHash[x].neg += y;
          }
          i += ps;
        }
        for (x in baseHash) {
          base = baseHash[x];
          if (pointsHash[x] == null) {
            pointsHash[x] = [parseFloat(x), base.pos, base.pos];
          }
        }
        ps = 3;
        points = [];
        i = 0;
        while (i < baseArray.length) {
          if (pointsHash[baseArray[i]] != null) {
            points = points.concat(pointsHash[baseArray[i]]);
          }
          i++;
        }
        datapoints.points = points;
        datapoints.pointsize = ps;
      };
      plot.hooks.processDatapoints.push(stackData);
    };
    $.plot.plugins.push({
      init: init,
      options: options,
      name: 'stacksplit',
      version: '0.1'
    });
  })(jQuery);

}).call(this);

/*
//@ sourceMappingURL=jquery.flot.simplestack.map
*/
